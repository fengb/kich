#!/usr/bin/env perl

use strict;
use warnings;
use Cwd qw[abs_path];
use File::Copy qw[move];
use File::Path qw[make_path];
use Getopt::Long;

# https://stackoverflow.com/a/6829502
sub source {
  my $name = shift;
  open my $file, "<", $name
    or die "could not open $name: $!";

  while (<$file>) {
    chomp;
    my ($k, $v) = split /=/, $_, 2;
    $v =~ s/^(['"])(.*)\1/$2/; #' fix highlighter
    $v =~ s/\$([a-zA-Z]\w*)/$ENV{$1}/g;
    $v =~ s/`(.*?)`/`$1`/ge; #dangerous
    $ENV{$k} = $v;
  }

  close $file;
}

sub starts_with {
  my $haystack = shift;
  my $needle = shift;
  return index($haystack, $needle) == 0;
}

sub uniq {
  my %seen;
  grep !$seen{$_}++, @_;
}

sub init_env {
  GetOptions(
    "c=s" => \$ENV{'KICH_CONFIG'}
  ) or die;

  length($ENV{'KICH_CONFIG'} // '') and source($ENV{'KICH_CONFIG'});
  !length($ENV{'KICH_SRC'} // '') and source("$ENV{'HOME'}/.kichconfig");

  $ENV{'KICH_TGT'} ||= $ENV{'HOME'};
  $ENV{'KICH_IGNORE'} ||= '';
}

sub or_names {
  my @merged = map {("-name", $_, "-or")} @_;
  pop @merged;
  return @merged;
}

sub find {
  my @args = map {$_ =~ s!([ ()])!\\$1!gr} @_;
  my $string = `find @args`;
  return split /\n/, $string;
}

sub ignore_files {
  my $files = $ENV{'KICH_IGNORE'};
  $files =~ s!^[ \n]+!!g;
  return split / *\n+ */, $files;
}

sub src_find {
  if (!exists $ENV{'KICH_IGNORE'}) {
    return find($ENV{'KICH_SRC'}, @_);
  } else {
    my @src_find_exclude = or_names(ignore_files());
    return find($ENV{'KICH_SRC'},
      "(", or_names(ignore_files()), ")", "-prune",
      "-or",
      "(", @_, ")", "-print"
    );
  }
}

# Removes paths that are prefixes of the next path:
# Example:
#     Library/CoreData
#     Library/CoreData/ExternalRecords
#     Library/CoreData/ExternalRecords/HTMLNotes
#   becomes
#     Library/CoreData/ExternalRecords/HTMLNotes
sub remove_prefix_paths {
  #sed '$!N; /\(.*\)\n\1\/.*/!P;D'
}

sub src_dirs {
  return src_find(qw[-not ( -name '*.link' -prune ) -type d]);
}

sub src_links {
  return src_find(qw[-name '*.link' -prune -or -type f])
}

sub tgt_from {
  my $name = shift;
  $name =~ s!^$ENV{'KICH_SRC'}!$ENV{'KICH_TGT'}!;
  $name =~ s!.link$!!;
  return $name;
}

sub src_from {
  my $tgt = shift;

  starts_with($tgt, $ENV{'KICH_TGT'}) || die "'$tgt' not in \$KICH_TGT ($ENV{'KICH_TGT'})";

  if ((-L $tgt) and !broke($tgt)) {
    return readlink($tgt);
  }

  my $src = $tgt;
  $src =~ s!^$ENV{'KICH_SRC'}!$ENV{'KICH_TGT'}!;

  if (-f $tgt) {
    return $src;
  } elsif (-d $tgt) {
    return "$src.link";
  } else {
    die 'wtf';
  }
}

sub rm_files {
  (scalar(@_) == 0) and return;

  my @files = @_;

  foreach my $file(@files) {
    print "✗  $file\n";
  }

  my $yn = <STDIN>;
  if (!starts_with(chomp($yn), "y")) {
    return;
  }

  unlink(@files);
}

sub broke {
  my $name = shift;
  return lstat $name && !stat $name;
}

my %commands = (
  install => sub {
    my @tgt_dirs = map {tgt_from $_} src_dirs;
    my @tgt_links = map {tgt_from $_} src_links;

    my @existdirs = grep {!-d $_} @tgt_dirs;
    my @existlinks = grep {!-l $_} @tgt_links;
    my @brokelinks = grep {broke $_} @tgt_links;

    rm_files(@existdirs, @existlinks, @brokelinks);

    make_path(@tgt_dirs);

    foreach my $dst(@tgt_links) {
      if (!-e $dst) {
        print "⇋  $dst\n";
        symlink src_from($dst), $dst;
      }
    }
  },

  sync => sub {
    my $tgt = shift;

    (-e $tgt) or die "'$tgt' is not found";
    (!-L $tgt) or die "'$tgt' is a symlink";

    my $src = src_from(abs_path("$tgt"));
    make_path(dirname($src));
    move($tgt, $src);
    symlink $src, $tgt;
  },

  unsync => sub {
    my $tgt = shift;

    (-L $tgt) or die "'$tgt' is not a symlink";

    my $src = readlink "$tgt";

    (-e $src) or die "'$src' is not found";
    starts_with($src, $ENV{'KICH_SRC'}) or die "'$tgt' is not synced";

    unlink "$tgt";
    move("$src", "$tgt");
  },

  uninstall => sub {
    my @tgt_links = map {tgt_from($_)} src_links;
    rm_files(@tgt_links);
  },

  env => sub {
    print "KICH_SRC='$ENV{'KICH_SRC'}'\n";
    print "KICH_TGT='$ENV{'KICH_TGT'}'\n";
    print "KICH_IGNORE='$ENV{'KICH_IGNORE'}'\n";
  },

  ls => sub {
    my @tgt_links = map {tgt_from $_} src_links;
    my @exist_links = grep {!broke $_} @tgt_links;
    print @exist_links;
  },

  clean => sub {
    my @kichlinks = find($ENV{'KICH_TGT'}, qw[-type l -lname], "$ENV{'KICH_SRC'}");
    my @brokelinks = grep {-L $_} @kichlinks;
    rm_files(@brokelinks);
  }
);

sub command {
  my $name = shift || "install";
  if ($commands{$name}) {
    $commands{$name}->();
  } else {
    die "'$1' is not a command";
  }
}

unless (caller) {
  init_env();
  command(@ARGV);
}
